# Authored by Gregory Szorc <gregory.szorc@gmail.com>. All rights reserved.

import json
import os.path

class TraceParser(object):
    '''Provides routines for analyzing trace files generated by
    running make.py --trace-log'''

    def __init__(self, path):
        '''Create a parser that operates on the path specified'''

        self.path = path

        with open(self.path, 'r') as f:
            l = f.readline()
            data = json.loads(l)

            assert data[0] == 'MAKEFILE_BEGIN'

            self.root_dir = data[1]['dir']

    def _parse_file(self, callback):
        with open(self.path, 'r') as f:
            for line in f:
                o = json.loads(line)
                callback(o[0], o[1])

    def get_target_execution_counts(self):
        '''Obtain a dictionary of target execution counts.

        Keys will be target names. Values will be integer times of execution.
        '''

        targets = {}

        def callback(action, data):
            if action != 'TARGET_BEGIN':
                return

            name = data['target']
            dir = data['dir']

            fullname = '%s%s' % ( dir, name )

            if fullname in targets:
                targets[fullname] += 1
            else:
                targets[fullname] = 1

        self._parse_file(callback)
        return targets

    def get_executed_commands(self):
        '''Obtains a list of commands that were invoked during make process'''

        commands = []

        def callback(action, data):
            if action != 'COMMAND_RUN':
                return

            commands.append((data['dir'], data['target'], data['cmd']))

        self._parse_file(callback)

        return commands

    def get_executed_commands_report(self):
        '''Obtains a report of the executed commands.

        The report classifies related commands, performs counts, etc. This is
        useful for seeing where hot spots in the build process are, etc.
        '''

        command_counts = {}

        for command in self.get_executed_commands():
            params = command[2].split()

            if not len(params):
                continue

            base = os.path.basename(params[0])

            # Many commands are wrapped by the main python executable. We
            # drill into them.
            if base.find('python') != -1:
                if len(params) < 2:
                    if base in command_counts:
                        command_counts[base] += 1
                    else:
                        command_counts[base] = 1

                    continue

                real = params[1]

                if not os.path.isabs(real):
                    real = os.path.join(command[0], real)

                real = os.path.normpath(real)

                if real in command_counts:
                    command_counts[real] += 1
                else:
                    command_counts[real] = 1
            else:
                if base in command_counts:
                    command_counts[base] += 1
                else:
                    command_counts[base] = 1

        return {
            'counts': command_counts
        }