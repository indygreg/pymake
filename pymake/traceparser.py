# Authored by Gregory Szorc <gregory.szorc@gmail.com>. All rights reserved.

import json
import os.path

class TraceParser(object):
    '''Provides routines for analyzing trace files generated by
    running make.py --trace-log'''

    def __init__(self, path):
        '''Create a parser that operates on the path specified'''

        self.path = path

        with open(self.path, 'r') as f:
            l = f.readline()
            data = json.loads(l)

            assert data[0] == 'PYMAKE_BEGIN'

            self.root_dir = data[2]['dir']

    def parse_file(self, callback, context=None):
        '''Parse the file the class was constructed with and call the
        supplied function with each event read

        The callback will receive in the following order:
          - str action performed
          - float time action performed
          - dict data in action
          - context passed into method
        '''
        with open(self.path, 'r') as f:
            for line in f:
                try:
                    o = json.loads(line)
                    callback(o[0], o[1], o[2], context)

                except ValueError, e:
                    pass

    def get_target_execution_counts(self):
        '''Obtain a dictionary of target execution counts.

        Keys will be target names. Values will be integer times of execution.
        '''

        targets = {}

        for m in self.get_pymake_instances():
            for makefile_id, makefile in m['makefiles'].iteritems():
                dir = makefile['dir']

                for target_id, target in makefile['targets'].iteritems():
                    name = target['name']

                    fullname = None

                    if len(name) > 0 and name[0] == os.sep:
                        fullname = name
                    else:
                        fullname = os.path.normpath(os.path.join(dir, name))

                    if fullname in targets:
                        targets[fullname] += 1
                    else:
                        targets[fullname] = 1

        return targets

    def get_jobs(self):
        '''Returns a list of jobs executed during trace.'''

        jobs = {}
        all = []

        def callback(action, time, data, context):
            if action == 'JOB_START':
                jobs[data['id']] = ( time, data )
                return

            if action == 'JOB_FINISH':
                id = data['id']

                # If this happens, the tracer is whacked.
                # TODO log a warning or something
                if id not in jobs:
                    return

                job = jobs[id]

                data = job[1]
                data['wall_time'] = time - job[0]
                all.append(data)

                l = []
                if data['executable']:
                    l.append(data['executable'])

                if data['shell']:
                    l.append(data['argv'])
                else:
                    l.extend(data['argv'])

                data['friendly_exec'] = ' '.join(l).replace('\n', '\\n')

                del jobs[id]

        self.parse_file(callback, jobs)
        return all

    def get_aggregate_jobs(self):
        '''Obtains job information then combines similar jobs.'''

        # Keys are normalized job type
        jobs = {}

        def create_record(name):
            return {
                'count': 0,
                'name': name,
                'wall_time': 0.0,
            }

        for job in self.get_jobs():
            record = None

            if job['shell']:
                if 'shell' in jobs:
                    record = jobs['shell']
                else:
                    record = create_record('shell')

            elif job['executable']:
                normalized = os.path.normpath(job['executable'])

                if normalized in jobs:
                    record = jobs[normalized]
                else:
                    record = create_record(normalized)
            else:
                command = job['argv'][0]

                if command in jobs:
                    record = jobs[command]
                else:
                    record = create_record(command)

            record['count'] += 1
            record['wall_time'] += job['wall_time']

            jobs[record['name']] = record

        return jobs.values()

    def get_pymake_instances(self):
        '''Obtains information about individual PyMake instances'''

        ctx = {
            'results':      [], # consolidated records
            'pymakes':      {}, # pymake id to dictionary
            'makefile_map': {}, # makefile id to pymake id
            'makefiles':    {}, # makefile id to dictionary
            'target_map':   {}, # target id to makefile id
            'targets':      {}, # target id to dictionary
            'command_map':  {}, # command id to target id
            'commands':     {}, # command id to dictionary
        }

        def callback(action, time, data, context):
            if action == 'PYMAKE_BEGIN':
                id = data['id']

                context['pymakes'][id] = {
                    'id':          id,
                    'dir':         data['dir'],
                    'targets':     data['targets'],
                    'time_start':  time,
                    'files':       data['makefiles'],
                    'makefiles':   {}
                }

            elif action == 'PYMAKE_FINISH':
                id = data['id']

                if id not in context['pymakes']:
                    return

                entry = context['pymakes'][id]
                entry['time_finish'] = time
                entry['wall_time'] = time - entry['time_start']

                del context['pymakes'][id]

                makefile_ids = []

                for make_id, pymake_id in context['makefile_map'].iteritems():
                    if id != pymake_id:
                        continue

                    makefile_ids.append(make_id)

                for make_id in makefile_ids:
                    del context['makefile_map'][make_id]

                    entry['makefiles'][make_id] = context['makefiles'][make_id]
                    del context['makefiles'][make_id]

                targets = {}

                for target_id, make_id in context['target_map'].iteritems():
                    if make_id in makefile_ids:
                        targets[target_id] = make_id

                for target_id, make_id in targets.iteritems():
                    del context['target_map'][target_id]

                    entry['makefiles'][make_id]['targets'][target_id] = context['targets'][target_id]
                    del context['targets'][target_id]

                commands = {}
                for command_id, target_id in context['command_map'].iteritems():
                    if target_id in targets.keys():
                        commands[command_id] = target_id

                for command_id, target_id in commands.iteritems():
                    del context['command_map'][command_id]

                    entry['makefiles'][targets[target_id]]['targets'][target_id]['commands'][command_id] = context['commands'][command_id]
                    del context['commands'][command_id]

                context['results'].append(entry)

            elif action == 'MAKEFILE_CREATE':
                entry = {
                    'targets': {},
                    'dir':     data['dir'],
                }

                id = data['id']
                context['makefile_map'][id] = data['context_id']
                context['makefiles'][id] = entry

            elif action == 'MAKEFILE_BEGIN':
                id = data['id']
                if id not in context['makefiles']:
                    return

                entry = context['makefiles'][id]
                entry['time_begin'] = time
                entry['dir']        = data['dir']
                entry['included']   = data['included']

            elif action == 'MAKEFILE_FINISH':
                id = data['id']
                if id not in context['makefiles']:
                    return

                entry = context['makefiles'][id]
                entry['time_finish'] = time

            elif action == 'TARGET_BEGIN':
                id = data['id']
                make_id = data['makefile_id']

                context['target_map'][id] = make_id
                context['targets'][id] = {
                    'time_start': time,
                    'name':       data['target'],
                    'vpath':      data['vpath'],
                    'commands':   {},
                }

            elif action == 'TARGET_FINISH':
                id = data['id']
                if id not in context['targets']:
                    return

                entry = context['targets'][id]
                entry['time_finish'] = time

            elif action == 'COMMAND_CREATE':
                id = data['id']
                target_id = data['target_id']

                context['command_map'][id] = target_id
                context['commands'][id] = {
                    'time_create': time,
                    'cmd':         data['cmd'],
                    'l':           data['l'],
                }

            elif action == 'JOB_START':
                id = data['id']
                if id not in context['commands']:
                    return

                entry = context['commands'][id]

                type = data['type']
                entry['type'] = type
                entry['time_start'] = time

                if type == 'popen':
                    entry['executable'] = data['executable']
                    entry['argv']       = data['argv']
                    entry['shell']      = data['shell']
                elif type == 'python':
                    entry['module'] = data['module']
                    entry['method'] = data['method']
                    entry['argv']   = data['argv']
                else:
                    raise Exception('unhandled job type: %s' % type)

            elif action == 'JOB_FINISH':
                id = data['id']
                if id not in context['commands']:
                    return

                entry = context['commands'][id]
                entry['result'] = data['result']
                entry['time_end'] = time
                entry['wall_time'] = time - entry['time_start']


        self.parse_file(callback, ctx)

        return ctx['results']

    def get_executed_commands(self):
        '''Obtains a list of commands that were invoked during make process'''

        commands = {
            'c': {},
            'l': []
        }

        def callback(action, time, data, context):
            if action == 'COMMAND_CREATE':
                id = data['id']
                context['c'][id] = {
                    'target': data['target_id'],
                    'l':      data['l'],
                    'cmd':    data['cmd'],
                }

            elif action == 'JOB_START':
                id = data['id']
                if id not in context['c']:
                    return

                entry = context['c'][id]
                type = data['type']
                entry['type'] = type
                entry['time_start'] = time

                if type == 'popen':
                    entry['executable'] = data['executable']
                    entry['argv']       = data['argv']
                    entry['shell']      = data['shell']
                elif type == 'python':
                    entry['module'] = data['module']
                    entry['method'] = data['method']
                    entry['argv']   = data['argv']
                else:
                    raise Exception('unhandled job type: %s' % type )

            elif action == 'JOB_FINISH':
                id = data['id']
                if id not in context['c']:
                    return

                entry = context['c'][id]

                entry['time_end'] = time
                entry['wall_time'] = time - entry['time_start']
                entry['result'] = data['result']

                context['l'].append(entry)
                del context['c'][id]

        self.parse_file(callback, commands)

        return commands['l']
