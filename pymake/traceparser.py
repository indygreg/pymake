# Authored by Gregory Szorc <gregory.szorc@gmail.com>. All rights reserved.

import json
import os.path

class TraceParser(object):
    '''Provides routines for analyzing trace files generated by
    running make.py --trace-log'''

    def __init__(self, path):
        '''Create a parser that operates on the path specified'''

        self.path = path

        with open(self.path, 'r') as f:
            l = f.readline()
            data = json.loads(l)

            assert data[0] == 'MAKEFILE_BEGIN'

            self.root_dir = data[1]['dir']

    def parse_file(self, callback, context=None):
        '''Parse the file the class was constructed with and call the
        supplied function with each event read'''
        with open(self.path, 'r') as f:
            for line in f:
                o = json.loads(line)
                callback(o[0], o[1], context)

    def get_target_execution_counts(self):
        '''Obtain a dictionary of target execution counts.

        Keys will be target names. Values will be integer times of execution.
        '''

        targets = {}

        def callback(action, data, context):
            if action != 'TARGET_BEGIN':
                return

            name = data['target']
            dir = data['dir']

            fullname = os.path.normpath(os.path.join(dir, name))

            if fullname.find(self.root_dir) == 0:
                fullname = fullname[len(self.root_dir):]

            if fullname in targets:
                targets[fullname] += 1
            else:
                targets[fullname] = 1

        self.parse_file(callback)
        return targets

    def get_executed_commands(self):
        '''Obtains a list of commands that were invoked during make process'''

        commands = []

        def callback(action, data, context):
            if action != 'COMMAND_RUN':
                return

            if not len(data['cmd']):
                return

            commands.append((data['dir'], data['target'], data['cmd']))

        self.parse_file(callback)

        return commands

    def get_executed_commands_report(self):
        '''Obtains a report of the executed commands.

        The report classifies related commands, performs counts, etc. This is
        useful for seeing where hot spots in the build process are, etc.
        '''

        command_counts = {}

        for command in self.get_executed_commands():
            params = command[2].split()

            if not len(params):
                continue

            base = os.path.basename(params[0])

            # Many commands are wrapped by the main python executable. We
            # drill into them.
            if base.find('python') != -1:
                if len(params) < 2:
                    if base in command_counts:
                        command_counts[base] += 1
                    else:
                        command_counts[base] = 1

                    continue

                real = params[1]

                if not os.path.isabs(real):
                    real = os.path.join(command[0], real)

                real = os.path.normpath(real)

                if real in command_counts:
                    command_counts[real] += 1
                else:
                    command_counts[real] = 1
            else:
                if base in command_counts:
                    command_counts[base] += 1
                else:
                    command_counts[base] = 1

        return {
            'counts': command_counts
        }

    def print_execution_tree(self, f):
        context = {
            'current_dir': self.root_dir,
            'level': 0
        }

        def callback(action, data, context):
            if action == 'MAKEFILE_BEGIN':
                dir = data['dir']
                assert dir.find(self.root_dir) == 0

                context['current_dir'] = dir[len(self.root_dir):]
                print >> f, '%sNEW MAKEFILE: %s' % ( ' ' * context['level'], context['current_dir'] )
                context['level'] += 1

            elif action == 'MAKEFILE_FINISH':
                context['level'] -= 1
                print >> f, '%sEND MAKEFILE' % ( ' ' * context['level'] )

            elif action == 'TARGET_BEGIN':
                name = data['target']

                print >> f, '%sBEGIN TARGET: %s' % ( ' ' * context['level'], name )
                context['level'] += 1

            elif action == 'TARGET_FINISH':
                name = data['target']

                context['level'] -= 1
                print >> f, '%sEND TARGET %s' % ( ' ' * context['level'], name )

            elif action == 'COMMAND_RUN':
                command = data['cmd']

                print >> f, '%s$ %s' % ( ' ' * context['level'], command )

        self.parse_file(callback, context)
